%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008

\chapter{Introduction}\label{introduction}

Subject of this thesis project is constructing a C programming language compiler for the soft-core processor PicoBlaze-6.

    \section{The C Programming Language}

    %% Tady budou chtit citace... ono ostatne asi vsude kde uvadim nejake roky

    The C programming language was created in the seventies %% TODO spisovne?
    of the twentieth century by Dennis Ritchie and Ken Thompson. In this project, I focused mainly on implementing its two latest standards, ISO/IEC 9899:1999 and partially ISO/IEC 9899:2011.

    \section{The Previous Project}
    Similar thesis topic was elaborated by Jakub Horník as his %% TODO citace
    master's thesis in year 2011.

    While he was writing the thesis, a new version of the target processor was released (see chapter~\ref{processor}). More of the resulting application is discussed in section~\ref{prev_pbcc}.

\chapter{The PicoBlaze Processor}\label{processor}

Picoblaze is a 8-bit processor created by Xilinx for their Spartan and Virtex Field-programmable gate array (FPGA) series as an embeddable circuit to implement sequential programming in the otherwise parallel FPGA architecture. This of course means the processor is not meant to be physically manufactured, yet it would be possible.

Historically, the name of the design was \texttt{KCPSM}, as for Ken Chapman's Programmable State Machine. This term is now still used in the FPGA design as the components are still caled \texttt{kcpsmX} where the \texttt{X} stands for the version of the processor.

The most up to date version is now 6 with its latest release 5 made public on 30 September 2012. The previous version, 3, had its last 7th revision released in October 2003. %% TODO citace?

    \section{Main Features}

    \begin{center}
    \begin{tabular}{ @{\extracolsep{\fill} } r | l }
        Program memory & Up to 4096 instructions \\

        Scratchpad RAM & Up to 256 bytes \\

        2 Register banks & Containing 16 8-bit registers each\\

        Output & 256 8-bit ports \\

        8-bit ALU & Supports shifting, adding and subtracting \\
                  & Provides AND, OR and XOR operations \\
                  & Compares and tests \\
                  & Implements carry and zero flags \\

        FPGA design & Can be included directly in the VHDL code \\
                    & No other equipment or code needed \\
    \end{tabular}
    \end{center}

    \section{Practical usage}

    A sequential processor, in comparison to parallel hardware design, is much more feasible for implementing state machines and simple cycles.

    \section{The difference between PicoBlaze-3 and PicoBlaze-6}

    There were major changes done to the PicoBlaze in the upgrade to the new version (that is still backwards-compatible). 
    The most important ones are covered in this section, in descending order according to their impact on programming in C and the compiler itself.

        \subsection{New \texttt{JUMP@} and \texttt{CALL@} Instructions}

        Indirect jumps and calls, provided the address of the function or label, are possible in the new version.

        This improves compatibility with sophisticated C programs greatly as it allows the implementation of function pointers and their calling.

        It also means there had to a new addressing mode introduced - the whole program memory can't be covered with only an 8-bit value, so the code's section is stored in the lower four bytes of the first register and the rest of the address in the second one.

        \subsection{Program Memory Changes}

        Due to the two newly added memory addressing pins, it is possible to address four times more program memory (now up to 4K), increasing the possible program size and complexity.

        \subsection{RAM Changes}

        The amount of RAM addressable by the program was increased to up to 256 bytes from 64, yet it depends on the target device the processor will be implemented on. 

        This was achieved by modifying the opcodes of instructions of the processor, not the internals.

        \subsection{Call stack}

        Only 30 levels of function call depth are now available compared to 31 of KCPSM3.

        \subsection{\texttt{ADDCY} and \texttt{SUBCY} Instruction Changes}

        The previous version of these instructions modified the zero flag only according to their own result. Now they add the previous zero to the current one.

        \subsection{New \texttt{REGBANK} and \texttt{STAR} Instructions}

        The new version of the processor now provides two sets of 16 general purpose registers that are switchable using the \texttt{REGBANK} instruction - this means only one of the sets can be accessed at a time.

        To store values in the inactive bank, the \texttt{STAR} instruction is provided - it's used to store a value from the active bank register in another register that is in the inactive bank.

        \subsection{New \texttt{COMPARECY} and \texttt{TESTCY} Instructions}

        Instructions added to make comparing multi-byte types easier. They store the flags (carry and zero) and propagate them according to the progress through the single bytes.

        \subsection{New \texttt{LOAD\&RETURN} Instruction and \texttt{STRING} Directive}

        The user (or compiler) can now specify a byte string location in the memory using the \texttt{STRING} directive in the assembly.

        Then, using the \texttt{LOAD\&RETURN} instruction, it's possible to load a constant value into a specified register and unconditionally return from a subroutine, making these very useful in conjunction to generate text strings to be presented to the user.

        \subsection{New \texttt{OUTPUTK} Instruction}

        This instruction allows the program to output a constant instead of loading it into a register and outputting it using the regular \texttt{OUTPUT}.



\chapter{Programming language compiler}

Most of the modern computer processors are programmed using a fairly complicated binary instruction set. To make writing more complex and powerful applications, we are now using programming languages that are translated (\emph{compiled}) into the low level binary form easily understood by the processor.

    \section{Compiler structure}

    A typical programming language compiler consists of two (or three) parts:

        \subsection{Front-end}

            Does syntactic and semantic analysis of the input code according to the lexical and grammatical rules of the given language.

            It produces the intermediate code as its output, to be further processed.

        \subsection{Intermediate Code Optimizer (optional)}

            Being input the intermediate code, it makes it smaller and/or more efficient, regardless of the target architecture.

        \subsection{Back\-end}

            The input in this case is the intermediate language, too. The back-end then takes it and transofrms it to the target assembly or directly the binary form for the target processor architecture.

            Architecture-dependent optimizations can take place in this phase.

\chapter{Compiler Choice}\label{compiler}

As starting a new compiler from scratch would not be possible in time limited by time that is available for the bachelor's thesis, I had to choose an existing one and modify it.

This basically rules out all of the proprietary compilers and the selection limited to those from the world of free and open source software. In the end, I was left with the following three.

%% TODO celou tu vec s popisem frontendu bude potreba vzit vic do hloubky

    \section{GNU Compiler Collection}

    The GNU Compiler Collection, more known as \texttt{GCC}, was started as a simple C compiler in year 1985 by Richard Stallman. It is now one of the most widely used compiler suites not only in open source systems.

    Due to its huge history and background, its code base is stable and mature but it also is very hard to read due to historical reasons and the fact basically everything is wrapped in several layers of macros.

    The documentation of the inner %% TODO funkcnost?
    is not very well arranged and it is hard to find it. Because of its heritage, the structure does not seem very transparent.

    \section{Low Level Virtual Machine}

    LLVM, or, as this project is targeting C compiling, its front-end Clang, is a modern project with a great gain of popularity as it implements the latest features and standards very fast and provides some interesting tools, like static analyzer

    Compared to GCC, it is a really young project, started in 2005, and more flexible as it is not governed by Free Software Foundation and the GNU Project.

    It is also interesting to mention its development is sponsored by big companies like Google or Apple.

    LLVM provides a very well documented intermediate representation of the compiled source code. Its documentation is a publicly visible document on their wiki page with every detail described.

    \section{Small Device C Compiler}

    SDCC is a simple (compared to the previous two) compiler aimed to be easily retargetable and provide a quality background for creating compilers for 8bit processors.

    It's not a very large project (especially when compared to GCC and LLVM) and it uses parts (for example, the preprocessor) of GCC.

    It optimizes the compiled source code with focusing on issues appearing on small devices.

    The intermediate code is not very well documented (there is a list of all the Icodes on the project's wiki) but is simple enough to be understandable.

    Unlike the previous two compilers, it provides opcodes for operations such as port access %% TODO overit, nejsem si ted uplne jisty a nemam to u sebe
    

\chapter{Existing Solutions}\label{existing}

    \section{PCComp}\label{pccomp}

    Picoblaze C Compiler, the project of Francesco Poderico, has its own page on Sourceforge, %% TODO link
    yet there are no files to download or source code in the repository and the only relevant activity visible is a question where to actually download the compiler.

    I managed to find a Windows binary in version 1.8.4 in a web archive and a user manual describing the compiler's features, both created in year 2005 or 2006.

    It supports compiling programs for PicoBlaze, PicoBlaze-2 and PicoBlaze-3.

    However, the limitations of the compiler are vast. It generates stack-based code. This is unfortunate because PicoBlaze lacks any stack. 

    The implementation of the C standard is not complete. Type conversions are missing. It is also impossible to use variable modifying keywords like \texttt{volatile}. Given that the compiler does not support any kind of optimization of the resulting code except dead code detection, it's not a big issue though, as the programmer can prevent the compiler from discarding the variables by simply using them.

    To list some issues when the flaws of the previous PBCC\ref{prev_pbcc} are taken in question:

    Only byte and word (1 and 2 bytes) types are supported and their conversions aren't always possible. Only one-dimensional arrays and no pointer arithmetic is implemented by the compiler.
    Global variables can be defined only on the global level. % TODO wut

    The compiled assembler is often buggy or even nonfunctional and probability of getting broken code is increasing with complexity of the input and especially the arithmetic expressions used.

    More on this topic is discussed in paper by Zbyněk Křivka and Rudolf Schönecker %% TODO link bibliografie nebo tak nejak


    \section{PBCC by Bohumil Nováček}\label{not_quite_c}

    %% https://dip.felk.cvut.cz/browse/details.php?f=F3&d=K13136&y=2008&a=xnovaceb&t=bach
    %% MORE TODO
    This bachelor thesis was written on Faculty of Electrical Engineering of Czech Technical University in Prague in year 2008 when only PCComp\ref{pccomp} existed.

    The compiler only allows the user to compile a
    small subset of the actual ISO/IEC 9899:1999 standard,
    to name a few limitations, it's not possible to use
    \texttt{struct}, \texttt{union}, \texttt{enum} nor \texttt{typedef} keywords,
    effectively limiting the user to use only the basic types which are in this case \texttt{void}, \texttt{char} and \texttt{int} (again 1 and 2 bytes).

    It doesn't support expression conditions, strings and multidimensional arrays either.

    These limitations are caused by the fact Bohumil decided to write the compiler
    from scratch without usage of any framework or front-end and the fact the time needed to finish a complete C compiler is far beyond the time-frame of a bachelor thesis.

    However, despite its simplicity, some optimization is implemented, 
    such as constants and the results of constant expressions being replaced by values directly.

    Also, the source code is not to be found anywhere on the Internet, only the text part of the thesis was made public.


    \section{PBCC by Jakub Horník}\label{prev_pbcc}

    %% FIXME ach jo, tohle je fakt hrozna cast, mel bych to prepsat, ty vety nedavaji smysl a nenavazuji

    PicoBlaze C Compiler is a project sponsored by Virtuální laboratoř aplikovaných mikroprocesorů %% TODO overit
    realized on the Faculty of Information Technology, Brno University of Technology.

    It was written in years 2010 - 2011 by Jakub Horník as a part of his master's thesis and is now maintained by Zbyněk Křivka, supervisor of this thesis.

    The compiler is based on the Small Device C Compiler (SDCC) modified to provide support for the processor so it offers a subset of features of SDCC in version 3.0.

    There is support for adding further optimization methods provided by SDCC, additionally to its own optimizations those are ran during the compilation process on the intermediate code.

    Data types supported are integers large from 1 to 4 bytes, there is also no problem with converting them.

    Usage of arrays (even multidimensional) and pointers is implemented, including their usage as function parameters.

    PicoBlaze-6 was released only a few months after Jakub started writing the thesis for the previous one, PicoBlaze-3. 
    He didn't focus on the new features at all and wrote the program only for the old one.
    This is the reason why function pointers aren't implemented and what I will be focusing on in this project.

    The main reason to rewrite the compiler from scratch is to avoid carrying all the legacy instructions and features and to focus on the cleanest possible implementation of the current revision of the processor.

    Jakub also suggests allocating the registers by coloring them and using the information for better results when memory access frequency is taken in question.

    This means I wrote the whole program again while using just a few parts from the original code.


\chapter{New Port Creation}\label{port}

SDCC is basically a framework for compiler creation, providing handy tools that make compiling for the programmer's platform easier.

Its architecture is divided into \emph{ports}, units containing code related only to one target platform. These can be divided even further to provide more flexibility regarding different types of processors.

    \section{Adding a New Port}

    As this process is not documented anywhere in the SDCC documentation and doing it properly would require deep and good understanding of the GNU autotools toolchain, the following procedure was used to add the new port to the SDCC source:

    \begin{enumerate}

    \item Create a port source directory in \texttt{src/}, in this case, I was calling it \texttt{pblaze}.

    \item Add the basic source files in the port directory, for example \texttt{main.c} and \texttt{main.h}. \texttt{main.c} has to contain an instance of \texttt{PORT} structure containing information about the port's specifications and pointers to functions that will be called during the compilation.

    \item Insert a new (unique) port ID into \texttt{src/port.h}, like this for example:

    \texttt{\#define TARGET\_ID\_PBLAZE    16}

    \item And create an \texttt{extern} reference to the \texttt{PORT} instance from \texttt{src/pblaze/main.c}, for example:

    \texttt{\#if !OPT\_DISABLE\_PBLAZE}

    \texttt{extern PORT pblaze\_port;}

    \texttt{\#endif}

    \item In \texttt{src/SDCCmain.c}, insert a reference to the structure defined in \texttt{src/pblaze/main.c}.

    \end{enumerate}

    \section{Tools Used}

        \subsection{pBlazASM}

        Open source assembler created by Mediatronix to be used for compiling the machine code source files directly to machine code in several formats. It can also create a representation (\texttt{.lst} files) that is then used in the simulator \ref{pblazsim}.

        However, the program itself is bug infested and crashes quite often. I had to modify its source to workaround the biggest problems (such as calling \texttt{free()} on a pointer that was not returned by \texttt{malloc()}).

        \subsection{pBlazSIM}\label{pblazsim}

        As the debugging capabilities of the processor are limited and running the programs on real hardware would be too complicated, possibility of usage a simulator of the target processor is more than welcome.

        One of the most recent ones, pBlazSIM, was created by Mediatronix, too. It is written in C++ and Qt, so its usage is not limited only to the Windows platform which is the only one Mediatronix distributes the binary form to.

        At first, I was running the simulator in \emph{Wine} (Windows libraries implementation for other platforms) but strangely enough, the only code that it could simulate, was the example that was packed in the archive with the binary.

        Then, I downloaded the source code from the repository on Google Code and compiled the program myself (this wasn't flawless, too, as the provided files aren't complete). Finally, the compiled version works all right and simulates the output properly.

        \subsection{PBSim}\label{pbsim}

        A project that is being developed on the University, started as a Master's project in year 2012.

        Bound to \emph{SDCC}.

        Tightly related to Eclipse, it's possible to use it as a part of the interface.


\chapter{Implementation Design}\label{design}

In this chapter, the technical details of the project are discussed.

\section{Base Layer}

Using pure C library calls and macros in a C++ project would be wasting potential of the language, that's why the project is building upon a wrapper library for the \emph{SDCC} internals instead of them directly.

The whole wrapper library is included in the \texttt{wrap.h} and \texttt{wrap.cc} files.

    \subsection{Approach}

    Every needed \emph{SDCC} structure is wrapped in its own class adding new methods.

    The C++ classes are inheriting the structures themselves (to provide ability to up-cast directly).

    No other member variables are added, the memory footprint is the same. Actually, the pointers between the classes and their parent structures can be converted safely in both ways. This is not encouraged though as the language itself doesn't support this operation implicitly.

    \subsection{Solution}

    Most of the code is generated using regular expressions, then modified by hand to provide the required functionality.

    The methods added to the classes are usually just wrapping the functions and macros from \emph{SDCC}.

    There were some, unfortunately, that required being copied over to the code due to higher type safety of C++ when compared to C. This is the case of \texttt{bool ICode::skipNoOp()} method for example.

\section{Utility classes}

To provide better readable code and easier debugging, there are some classes provided.

Everything covered here can be found in the \texttt{util.h} and \texttt{util.cc} files.

    \subsection{Emitter}\label{emitter}

    Working in a similar fashion to the streams in the \emph{C++ STL} library, this class implements the final assembly output.

    The single global instance of this class is initialized on start-up, configuring the output file and output format to hide these details from the generating code itself.

    Streaming (or left shift) operators are overloaded to make the instruction emitting stand out from the code.

\section{Instruction generator}

\texttt{gen.h} and \texttt{gen.cc}

\section{Variable storage}

All the included sections are named after the classes in the source code to provide a comprehensible description of their purpose.

\texttt{ralloc.h} and \texttt{ralloc.cc}

    \subsection{Allocator}

    Singleton class used as an entrance to the generator itself.

    \subsection{Byte Subclasses - MemoryCell and Register}

    \subsection{Bank}

    Two instances of this class are present in the compiler, for each register bank contained in the processor.

    It collects all 16 registers and manages their allocation for variables and handles their clearing or moving to memory.

    \subsection{Memory}

\chapter{Port Features}\label{features}

\chapter{Conclusion}\label{conclusion}


\cite{TBD}
%=========================================================================
