%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008

\definecolor{gray}{gray}{0.5}
\newcommand{\todo}[1]{\textcolor{red}{TODO\:} \textcolor{gray}{#1}}

\chapter{Introduction}\label{introduction}

Subject of this thesis project is constructing a C programming language compiler for the soft-core processor PicoBlaze-6.

    \section{The C Programming Language}

    \todo{citace, citace, citace}

    The C programming language was created in the seventies \todo{spisovne?}
    of the twentieth century by Dennis Ritchie and Ken Thompson. In this project, I focused mainly on implementing its two latest standards, ISO/IEC 9899:1999 and partially ISO/IEC 9899:2011.

    \section{The Previous Project}
    Similar thesis topic was elaborated by Jakub Horník as his \todo{citace}
    master's thesis in year 2011.

    While he was writing the thesis, a new version of the target processor was released (see chapter~\ref{processor}). More of the resulting application is discussed in section~\ref{prev_pbcc}.

\chapter{The PicoBlaze Processor}\label{processor}

Picoblaze is a 8-bit processor created by Xilinx Inc. for their Spartan and Virtex FPGA\footnote{Field-programmable gate array} series as an embeddable circuit to implement sequential programming in the parallel FPGA architecture. This of course means the processor is not meant to be physically manufactured, yet it would be possible.

Historically, the name of the design was \texttt{KCPSM}, as for Ken Chapman's Programmable State Machine. This term is now still used in the FPGA design - the components are still caled \texttt{kcpsmX} where \texttt{X} stands for the version of the processor.

The most up to date version is now 6 with its latest release 5 published on 30 September 2012. The previous version, 3, had its last 7th revision released in October 2003. \todo{citace nebo aspon link na forum}

    \section{Main Features}

    \begin{center}
    \begin{tabular}{ @{\extracolsep{\fill} } r | l }
        Program memory & Up to 4096 instructions \\

        Scratchpad RAM & Up to 256 bytes \\

        2 Register banks & Containing 16 8-bit registers each\\

        Output & 256 8-bit ports \\

        8-bit ALU & Supports shifting, adding and subtracting \\
                  & Provides AND, OR and XOR operations \\
                  & Compares and tests \\
                  & Implements carry and zero flags \\

        FPGA design & Can be included directly in the VHDL code \\
                    & No other equipment or code needed \\
    \end{tabular}
    \end{center}

    \section{Practical usage}

    A sequential processor, in comparison to parallel hardware design, is much more feasible for implementing state machines and computational cycles.

    \todo{Pripadne nejake linky na pripady/priklady uziti atp}

    \section{New features and properties of PicoBlaze-6}

    Compared to the previous version, there were major changes in PicoBlaze's design after the upgrade to the sixth version, which is still backwards-compatible.

    The most important ones are covered in this section in descending order according to their impact on programming in C and the compiler itself.

        \subsection{New \texttt{JUMP@} and \texttt{CALL@} Instructions}

        Indirect jumps and calls, provided the address of the function or label, are possible in the new version.

        This improves compatibility with sophisticated C programs greatly as it allows the implementation of function pointers and their calling.

        It also means there had to a new addressing mode introduced - the whole program memory can't be covered with only an 8-bit value, so the code's section is stored in the lower four bytes of the first register and the rest of the address in the second one.

        \subsection{New \texttt{REGBANK} and \texttt{STAR} Instructions}

        The new version of the processor now provides two sets of 16 general purpose registers that are switchable using the \texttt{REGBANK} instruction - this means only one of the sets can be accessed at a time.

        To store values in the inactive bank, the \texttt{STAR} instruction is provided - it's used to store a value from the active bank register in another register that is in the inactive bank.

        \subsection{\texttt{ADDCY} and \texttt{SUBCY} Instruction Changes}

        The previous version of these instructions modified the zero flag only according to their own result. Now they add the previous zero to the current one.

        \subsection{New \texttt{COMPARECY} and \texttt{TESTCY} Instructions}

        Instructions added to make comparing multi-byte types easier. They store the flags (carry and zero) and propagate them according to the progress through the single bytes.

        \subsection{Program Memory Changes}

        Due to the two newly added memory addressing pins, it is possible to address four times more program memory (now up to 4K), increasing the possible program size and complexity.

        \subsection{RAM Changes}

        The amount of RAM addressable by the program was increased to up to 256 bytes from 64, yet it depends on the target device the processor will be implemented on. 

        This was achieved by modifying the opcodes of instructions of the processor, not the internals.

        \subsection{Call stack}

        Only 30 levels of function call depth are now available compared to 31 of KCPSM3.

        \subsection{New \texttt{LOAD\&RETURN} Instruction and \texttt{STRING} Directive}

        The user (or compiler) can now specify a byte string location in the memory using the \texttt{STRING} directive in the assembly.

        Then, using the \texttt{LOAD\&RETURN} instruction, it's possible to load a constant value into a specified register and unconditionally return from a subroutine, making these very useful in conjunction to generate text strings to be presented to the user.

        \subsection{New \texttt{OUTPUTK} Instruction}

        This instruction allows the program to output a constant instead of loading it into a register and outputting it using the regular \texttt{OUTPUT}.



\chapter{Programming language compiler}

Most of the modern computer processors are programmed using a fairly complicated binary instruction set. To make writing more complex and powerful applications, we are now using programming languages that are translated (\emph{compiled}) into the low level binary form easily understood by the processor.

    \section{Compiler structure}

    A typical programming language compiler consists of two (or three) parts:

        \subsection{Front-end}

            Does lexical, syntactic and semantic analysis of the input code according to the rules of the given language.

            It produces the intermediate code as its output, to be further processed.

            \subsubsection{Lexical analysis}

                As the first part of the front-end, the input string of characters is broken into tokens according to the grammatical rules which are set by the language standard.

                In the case of the C language, they are in the form of regular expressions which means they are being matched by a state machine.

            \subsubsection{Syntactic analysis}

                
            \subsubsection{Semantic analysis}
            

        \subsection{Intermediate Code}

            \subsubsection{The Intermediate Code Optimizer}

                Being input the intermediate code, it makes it smaller and/or more efficient, regardless of the target architecture.

        \subsection{Back\-end}

            The input in this case is the intermediate language, too. The back-end then takes it and transofrms it to the target assembly or directly the binary form for the target processor architecture.

            Architecture-dependent optimizations can take place in this phase.

\chapter{Compiler Choice}\label{compiler}

As starting a new compiler from scratch would not be possible in the limited time frame of a bachelor's thesis, I had to choose an existing front-end and provide a corresponding back-end part for the target platform.

This basically rules out all of the proprietary compilers and the selection limited to those from the world of free and open source software. In the end, the choice consisted of the following three ones:

    \section{GNU Compiler Collection}

    The GNU Compiler Collection, more known as \texttt{GCC}, was started as a simple C compiler in year 1985 by Richard Stallman. It is now one of the most widely used compiler suites not only in open source systems.

    Due to its huge history and background, its code base is stable and mature but it also is very hard to read due to historical reasons and the fact basically everything is wrapped in several layers of macros.

    The documentation of the inner functionality is not very well arranged and it is hard to find it. Because of its heritage, the structure does not seem very transparent.

    Free Software Foundation and the GNU Project are holding governance over the development and are prohibiting major changes to the architecture or code style which drives many new developers away.

    \section{Low Level Virtual Machine}

    LLVM is a modern project with a gaining popularity in past years for implementing the features very fast and providing of interesting and useful tools, like static analyzer.

    Its C and C++ front-end, Clang, is adding the latest features of the new language standards and their drafts sooner than the competitors.

    Compared to GCC, LLVM is a really young project. It was founded in 2005. The codebase is dynamically changing, written in C++ with heavy usage of templates and automatically generated code.

    Its development is sponsored by companies like Google, for example to provide ability to run native applications in the browser (NaCl project) or Apple, which utilizes the ecosystem in the official development toolkit provided for their products.

    LLVM provides a very well documented intermediate representation of the compiled source code. Its documentation is publicly visible on their wiki page, every necessary detail is described and the community provides several easy ways to be approached.

        \subsection{Architecture}

        LLVM is strictly separated into front and back ends, divided by the LLVM intermediate code that is heavily optimized and it's runnable directly in a virtual machine (hence the name Low Level \emph{Virtual Machine})

    \section{Small Device C Compiler}

    SDCC is a simple (compared to the previous two) compiler aimed to be easily retargetable and provide a quality background for creating compilers for 8bit processors.

    It's not a very large project (especially when compared to GCC and LLVM) and it uses parts (for example, the preprocessor) of GCC.

    It optimizes the compiled source code with focusing on issues appearing on small devices.

    The intermediate code is not documented very well (there is a list of all the Icodes on the project's wiki) but is simple enough to be understandable.

    %does it?
%     Unlike the previous two compilers, it provides opcodes for operations such as port access %% TODO overit, nejsem si ted uplne jisty a nemam to u sebe

\chapter{Existing Solutions}\label{existing}

    \section{PCComp}\label{pccomp}

    Picoblaze C Compiler, the project of Francesco Poderico, has its own page on Sourceforge, \todo{link}
    yet there are no files to download or source code in the repository and the only relevant activity visible is a question where to actually download the compiler.

    I managed to find a Windows binary in version 1.8.4 in a web archive and a user manual describing the compiler's features, both created in year 2005 or 2006.

    However, the limitations of the compiler are vast. It generates stack-based code. This is unfortunate because PicoBlaze lacks any stack. 

        \subsection{Features}

        The compiler is not strictly following the C standard and implements only its small subset.

        PicoBlaze, PicoBlaze-2 and PicoBlaze-3 support.

        Byte and word (1 and 2 bytes) types only are supported.

        One-dimensional arrays without any pointer arithmetic are implemented by the compiler.

        \subsection{Limitations}

        Type conversions are missing, as are variable modifiers(e.g. \texttt{volatile}). 

        The compiler doesn't support any kind of resulting code optimization, except dead branch detection.

        To list some issues when the flaws of the previous PBCC\ref{prev_pbcc} are taken in question:

        The compiled assembly is often buggy or even nonfunctional and the probabilty of getting broken code is increasing with the complexity of the input source code and the arithmetic expressions in particular.

    \section{PBCC by Bohumil Nováček}\label{not_quite_c}

    %% https://dip.felk.cvut.cz/browse/details.php?f=F3&d=K13136&y=2008&a=xnovaceb&t=bach
    \todo{vic popsat, dodat link}
    This bachelor thesis was written on Faculty of Electrical Engineering of Czech Technical University in Prague in year 2008 when only PCComp\ref{pccomp} existed.

    Bohumil has written the program as a part of his bachelor thesis, resulting in great \todo{in great TODO}

        \subsection{Features}

        The compiler only allows the user to compile a small subset of the actual ISO/IEC 9899:1999 standard.

        Processor support is limited to PicoBlaze-3.

        The types supported are \texttt{void}, \texttt{char} and \texttt{int}.

        There is support for one-dimensional arrays only.

        \subsection{Limitations}

        There is no support for any user-defined type, be it only a typedef or a complex type (\texttt{struct}, \texttt{union}, \texttt{enum}).

    ,
    to name a few limitations, it's not possible to use
    nor \texttt{typedef} keywords,
    effectively limiting the user to use only the basic types which are in this case  (again 1 and 2 bytes).

    It doesn't support expression conditions, strings and multidimensional arrays either.

    These limitations are caused by the fact Bohumil decided to write the compiler
    from scratch without usage of any framework or front-end and the fact the time needed to finish a complete C compiler is far beyond the time-frame of a bachelor thesis.

    However, despite its simplicity, some optimization is implemented, 
    such as constants and the results of constant expressions being replaced by values directly.

    Also, the source code is not to be found anywhere on the Internet, only the text part of the thesis was made public.


    \section{PBCC by Jakub Horník}\label{prev_pbcc}

    \todo{FIXME prepsat}

    PicoBlaze C Compiler is a project sponsored by Virtuální laboratoř aplikovaných mikroprocesorů \todo{Overit}
    realized on the Faculty of Information Technology, Brno University of Technology.

    It was written in years 2010 - 2011 by Jakub Horník as a part of his master's thesis and is now maintained by Zbyněk Křivka, supervisor of this thesis.

    The compiler is based on the Small Device C Compiler (SDCC) modified to provide support for the processor so it offers a subset of features of SDCC in version 3.0.

    There is support for adding further optimization methods provided by SDCC, additionally to its own optimizations those are ran during the compilation process on the intermediate code.

    Data types supported are integers large from 1 to 4 bytes, there is also no problem with converting them.

    Usage of arrays (even multidimensional) and pointers is implemented, including their usage as function parameters.

    PicoBlaze-6 was released only a few months after Jakub started writing the thesis for the previous one, PicoBlaze-3. 
    He didn't focus on the new features at all and wrote the program only for the old one.
    This is the reason why function pointers aren't implemented and what I will be focusing on in this project.

    The main reason to rewrite the compiler from scratch is to avoid carrying all the legacy instructions and features and to focus on the cleanest possible implementation of the current revision of the processor.

    Jakub also suggests allocating the registers by coloring them and using the information for better results when memory access frequency is taken in question.

    This means I wrote the whole program again while using just a few parts from the original code.


\chapter{New Port Creation}\label{port}

SDCC is basically a framework for compiler creation, providing handy tools that make compiling for the programmer's platform easier.

Its architecture is divided into \emph{ports}, units containing code related only to one target platform. These can be divided even further to provide more flexibility regarding different types of processors.

    \section{Adding a New Port}

    As this process is not documented anywhere in the SDCC documentation and doing it properly would require deep and good understanding of the GNU autotools toolchain, the following procedure was used to add the new port to the SDCC source:

    \begin{enumerate}

    \item Create a port source directory in \texttt{src/}, in this case, I was calling it \texttt{pblaze}.

    \item Add the basic source files in the port directory, for example \texttt{main.c} and \texttt{main.h}. \texttt{main.c} has to contain an instance of \texttt{PORT} structure containing information about the port's specifications and pointers to functions that will be called during the compilation.

    \item Insert a new (unique) port ID into \texttt{src/port.h}, like this for example:

    \texttt{\#define TARGET\_ID\_PBLAZE    16}

    \item And create an \texttt{extern} reference to the \texttt{PORT} instance from \texttt{src/pblaze/main.c}, for example:

    \texttt{\#if !OPT\_DISABLE\_PBLAZE}

    \texttt{extern PORT pblaze\_port;}

    \texttt{\#endif}

    \item In \texttt{src/SDCCmain.c}, insert a reference to the structure defined in \texttt{src/pblaze/main.c}.

    \end{enumerate}

    \section{Tools Used}

        \subsection{pBlazASM}\label{pblazasm}

        PBlazASM is an open source assembler created by Mediatronix to be used for compiling the machine code source files directly to machine code in several formats. It can also create a representation (\texttt{.lst} files) that is then used in the simulator \ref{pblazsim}.

        However, the program itself is bug infested and crashes quite often. There were some trivial bugs that were possible to be fixed quickly, such as calling \texttt{free()} on a pointer that was not returned by \texttt{malloc()}).

        \subsection{pBlazSIM}\label{pblazsim}

        As the debugging capabilities of the processor are limited and running the programs on real hardware would be too complicated, possibility of usage a simulator of the target processor is more than welcome.

        One of the most recent ones, pBlazSIM, was created by Mediatronix, too. It is written in C++ and Qt, so its usage is not limited only to the Windows platform which is the only one Mediatronix distributes the binary form to.

            \subsubsection{Running under Linux}

            First attempts to run the simulator in \emph{Wine}\footnote{WINE is not an Emulator - an open source Windows API implementation} were quite unsuccessful as it was capable of simulation only the code which was included in the distributed binary package.

            \todo{Citace/linky}
            However, the application itself is hosted under the GPLv2 open source license in the Google Code repository. 

            It's not possible to compile it directly from the source provided (at least at the time of writing of the thesis). The needed steps to finish the compilation successfully are fixing the \texttt{qmake} project file to include all needed source files and adding one missing icon for the GUI (for example by copying the existing ones in different colors).

            The hand-compiled version is capable of running the assembly files generated by \ref{pblazasm} well, including all features of its graphical user interface.

        \subsection{PBSim}\label{pbsim}

        A project that is being developed on the University, started as a Master's project in year 2012.

        Bound to \emph{SDCC}.

        Tightly related to Eclipse, it's possible to use it as a part of the user interface.

        


\chapter{Implementation Design}\label{design}

In this chapter, the technical details of the project are discussed.

    \section{Base Layer}

    Using pure C library calls and macros in a C++ project would be wasting potential of the language, that's why the project is building upon a wrapper library for the \emph{SDCC} internals instead of them directly.

    The whole wrapper library is included in the \texttt{wrap.h} and \texttt{wrap.cc} files.

        \subsection{Approach}

        Every needed \emph{SDCC} structure is wrapped in its own class adding new methods.

        The C++ classes are inheriting the structures themselves (to provide ability to up-cast directly).

        No other member variables are added, the memory footprint is the same. Actually, the pointers between the classes and their parent structures can be converted safely in both ways. This is not encouraged though as the language itself doesn't support this operation implicitly.

        \subsection{Solution}

        Most of the code is generated using regular expressions, then modified by hand to provide the required functionality.

        The methods added to the classes are usually just wrapping the functions and macros from \emph{SDCC}.

        There were some, unfortunately, that required being copied over to the code due to higher type safety of C++ when compared to C. This is the case of \texttt{bool ICode::skipNoOp()} method for example.

    \section{Utility classes}

    To provide better readable code and easier debugging, there are some classes provided.

    Everything covered here can be found in the \texttt{util.h} and \texttt{util.cc} files.

        \subsection{Emitter}\label{emitter}

        Working in a similar fashion to the streams in the \emph{C++ STL} library, this class implements the final assembly output.

        The single global instance of this class is initialized on start-up, configuring the output file and output format to hide these details from the generating code itself.

        Streaming (or left shift) operators are overloaded to make the instruction emitting stand out from the code.

        Many instructions have different forms for single- and multi- byte variables used as their operands. For this purpose, the class also provides an iterator variable, declared as \texttt{static public int i}.

    \section{Instruction generator}

    \texttt{gen.h} and \texttt{gen.cc}

    To avoid code duplication as much as possible, every instruction is generated using cycles wrapping the \texttt{Emitter}\ref{emitter} class.

    This helps code clarity in the \texttt{ICode} processing functions themselves, limiting it to pure logic of handling the needed information.

    \section{Variable storage}

    All the included sections are named after the classes in the source code to provide a comprehensible description of their purpose.

    \texttt{ralloc.h} and \texttt{ralloc.cc}

        \subsection{Allocator}

        Singleton class used as an entrance to the generator itself.

        \subsection{Byte Subclasses - MemoryCell and Register}

        \subsection{Bank}

        Two instances of this class are present in the compiler, corresponds to each register bank contained in the processor.

        It collects all 16 registers and manages their allocation for variables and handles their clearing or moving to memory.

        \subsection{Memory}


\chapter{Port Features}\label{features}

    \section{Code clarity}

    \todo{extensibility asi neni slovo}
    The extensibility and readability of this port is not comparable to any other port. The code generation itself takes only about 5 lines of code for each \texttt{ICode}, compared to tens to hundreds in PBCCv2\ref{prev_pbcc}.

    Providing a C++ API also helps by providing more syntax sugar for anybody who wants to further modify the compiler. Using class methods instead of macros and functions also adds the possibility to use an IDE\footnote{Integrated Development Environment} with method suggestion.

    \section{KCPSM6 support}

    There is no other compiler designed to produce code for the newest revision of the PicoBlaze processor.

    The most modern ones support only KCPSM3 so they miss the opportunity to save not only the program space (meaning less CPU cycles for the same program) but also the scratchpad memory and registers (which means the program will utilize less CPU cycles again).

\chapter{Conclusion}\label{conclusion}


\cite{TBD}
%=========================================================================
